import * as cdk from "aws-cdk-lib";
import { PhysicalName } from "aws-cdk-lib";
import * as s3 from "aws-cdk-lib/aws-s3";
import * as kms from "aws-cdk-lib/aws-kms";
import * as iam from "aws-cdk-lib/aws-iam";
import * as lambda from "aws-cdk-lib/aws-lambda";
import * as logs from "aws-cdk-lib/aws-logs";
import { NagSuppressions } from "cdk-nag";

interface S3CopyStackProps extends cdk.StackProps {
  bucketName: string;
  bucketArn: string;
}
export class s3CopyStack extends cdk.Stack {
  public readonly cleanS3Bucket: s3.Bucket;
  public readonly kmsEncryptionKey: kms.Key;
  constructor(scope: cdk.App, id: string, props: S3CopyStackProps) {
    super(scope, id, props);

    // Create a new KMS key for encrypting the S3 bucket
    this.kmsEncryptionKey = new kms.Key(this, "cleanBucketKey", {
      enableKeyRotation: true,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });

    // Create a log bucket for storing access logs
    const cleanLogBucket = new s3.Bucket(this, "cleanLogS3Bucket", {
      bucketName: PhysicalName.GENERATE_IF_NEEDED, // Replace with your desired log bucket name
      enforceSSL: true, // Force SSL for data transfer
      blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL, // Block all public access
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });

    // Create a log group for storing access logs
    const cleanLogGroup = new logs.LogGroup(this, "cleanLogGroup", {
      logGroupName: PhysicalName.GENERATE_IF_NEEDED, // Replace with your desired log group name
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });

    // Create a new S3 bucket
    this.cleanS3Bucket = new s3.Bucket(this, "cleanS3Bucket", {
      bucketName: PhysicalName.GENERATE_IF_NEEDED,
      encryption: s3.BucketEncryption.KMS, // Server-side encryption with KMS keys
      encryptionKey: this.kmsEncryptionKey, // Use the KMS key for encryption
      blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL, // Block all public access
      enforceSSL: true, // Force SSL for data transfer
      serverAccessLogsBucket: cleanLogBucket, // Enable access logging to the log bucket
      serverAccessLogsPrefix: "s3", // Prefix for access logs
      removalPolicy: cdk.RemovalPolicy.DESTROY, // Destroy the bucket on stack deletion
    });

    // Define the IAMLambdaS3CopyObjectPolicy
    const iamLambdaS3CopyObjectPolicy = new iam.Policy(
      this,
      "IAMLambdaS3CopyObjectPolicy",
      {
        policyName: "LambdaS3CopyObjectPolicy",
        statements: [
          new iam.PolicyStatement({
            sid: "AllowGetObjectSourceBucket",
            actions: ["s3:GetObject", "s3:GetObjectTagging"],
            resources: [`${props.bucketArn}/*`],
          }),
          new iam.PolicyStatement({
            sid: "AllowPutObjectDestinationBucket",
            actions: ["s3:PutObject", "s3:PutObjectTagging"],
            resources: [`${this.cleanS3Bucket.bucketArn}/*`],
          }),
          new iam.PolicyStatement({
            sid: "AllowLogs",
            actions: ["logs:CreateLogGroup"],
            resources: [
              `arn:${this.partition}:logs:${this.region}:${this.account}`,
            ],
          }),
          new iam.PolicyStatement({
            sid: "AllowLogStreams",
            actions: ["logs:CreateLogStream", "logs:PutLogEvents"],
            resources: [
              `arn:${this.partition}:logs:${this.region}:${this.account}::log-group:/aws/lambda/GuardDuty-S3-${props.bucketArn}`,
            ],
          }),
        ],
      }
    );

    NagSuppressions.addResourceSuppressions(
      iamLambdaS3CopyObjectPolicy,
      [
        {
          id: "AwsSolutions-IAM4",
          reason: "Leveraging the default execution policy which isn't scoped.",
        },
        {
          id: "AwsSolutions-IAM5",
          reason:
            "Suppress Wildcard nags as it is scoped to any path within the bucket arn provided for PUT requests",
        },
      ],
      true
    );

    // Create the IAMLambdaS3CopyObjectRole
    const iamLambdaS3CopyObjectRole = new iam.Role(
      this,
      "IAMLambdaS3CopyObjectRole",
      {
        assumedBy: new iam.ServicePrincipal("lambda.amazonaws.com"),
        managedPolicies: [
          iam.ManagedPolicy.fromAwsManagedPolicyName(
            "service-role/AWSLambdaBasicExecutionRole"
          ),
        ],
      }
    );
    iamLambdaS3CopyObjectPolicy.attachToRole(iamLambdaS3CopyObjectRole);

    NagSuppressions.addResourceSuppressions(
      iamLambdaS3CopyObjectRole,
      [
        {
          id: "AwsSolutions-IAM4",
          reason: "Leveraging the default execution policy which isn't scoped.",
        },
      ],
      true
    );
    // Create the CopyTaggedS3ObjectLambdaFunction
    const copyTaggedS3ObjectLambdaFunction = new lambda.Function(
      this,
      "CopyTaggedS3ObjectLambdaFunction",
      {
        functionName: "S3MalwareSolution-CopyTaggedS3Object2",
        runtime: lambda.Runtime.PYTHON_3_12,
        code: lambda.Code.fromAsset("lambda"),
        handler: "index.lambda_handler",
        role: iamLambdaS3CopyObjectRole,
        environment: {
          SOURCE_BUCKET_NAME: props.bucketName,
          DEST_BUCKET_NAME: `${this.cleanS3Bucket.bucketName}`,
        },
        memorySize: 128,
        timeout: cdk.Duration.seconds(30),
        architecture: lambda.Architecture.X86_64,
      }
    );
    //Create the EventBridge Rule for S3 Tag
    // const prefix = "S3Malware-CopyS3Object-";
    // const maxLength = 64;
    // const bucketNameLength = props.bucketName.length;
    // const remainingLength = maxLength - prefix.length;
    // const truncatedBucketName = props.bucketName.slice(0, remainingLength);
    // const ruleName = `${prefix}${truncatedBucketName}`;
    const GuardDutyCopyS3ObjectRule = new cdk.aws_events.Rule(
      this,
      "GuardDutyCopyS3ObjectRule",
      {
        //ruleName: `S3Malware-CopyS3Object-${props.bucketName}`.slice(0, 64),
        ruleName: "S3Malware-CopyS3Object",
        description: `Copy GuardDuty scanned S3 objects from: ${props.bucketName} to clean: ${this.cleanS3Bucket.bucketName}`,
        eventPattern: {
          source: ["aws.guardduty"],
          detailType: ["GuardDuty Malware Protection Object Scan Result"],
          detail: {
            scanStatus: ["COMPLETED"],
            resourceType: ["S3_OBJECT"],
            bucket: {
              name: [props.bucketName],
            },
            scanResultDetails: {
              scanResultStatus: ["NO_THREATS_FOUND"],
            },
          },
        },
      }
    );
    GuardDutyCopyS3ObjectRule.addTarget(
      new cdk.aws_events_targets.LambdaFunction(
        copyTaggedS3ObjectLambdaFunction
      )
    );
  }
}
